# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - 一个交错级数的求和![image](https://github.com/user-attachments/assets/d82be6fb-1aec-4fa9-b1c0-bc6781ff1656)，对变量n从1到2N进行循环。每一项的值为(−1)^n·n/(n+1)(交错符号的分式),将每一项的值依次累加到 total 中，最终返回 total，即该级数的和。不过这种结构在浮点计算中可能导致相邻误差抵消，因此容易出现数值不稳定。

2. `sum_S2(N)` 函数实现：
   - 将原来的交错级数重写为两个子级数相减的形式![image](https://github.com/user-attachments/assets/9de9b7bf-c456-46f9-b4c7-927d8eda5a96)。定义两个求和变量sum1和sum2: sum1采用依次累加(2n−1)/2n，sum2采用依次累加2n/(2n+1)。最后返回sum2−sum1，即为整个级数的值。改写为两项独立求和形式，避免了交错项累加带来的舍入误差，有更好的数值稳定性。

3. `sum_S3(N)` 函数实现：
   - 实现与前两个等价的表达式的另一种形式：![image](https://github.com/user-attachments/assets/3c08c239-f3d3-4db5-8068-e2ac2ca4fd5b)，使用循环从n=1到N。每项为1/2n(2n+1)，直接累加到total中。返回最终的 total，即为该级数的和。该表达式为正项级数，且项值递减，通常认为其数值最稳定、误差最小，可用作误差分析的“参考值”或“精确近似”。

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 | 2.8361e-01 |  2.8361e-01 |  2.8361e-01 |  -3.9146e-16   |   4.6975e-15   |
| 100 |3.0437e-01 | 3.0437e-01  |  3.0437e-01 |  -2.5533e-15   |   -1.5065e-13  |
| 1000 |3.0660e-01|  3.0660e-01 |  3.0660e-01 |  -1.1587e-14   |   -5.7513e-12  |
| 10000 |3.0683e-01| 3.0683e-01 |  3.0683e-01 |  -5.2648e-14   |  -5.6153e-11   |

### 4.2 误差分析图
![image](https://github.com/user-attachments/assets/71de2ee1-7f06-43cd-b584-3c38497411a5)


## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - S3(N)是通过正项级数直接求和的方式，数值最稳定，可作为高精度参考值。S1(N)是交错级数，存在显著的数值误差，特别是当项数增大时，舍入误差容易积累或抵消。S2(N)虽然将交错结构拆开为两个独立求和部分，但这两个和分别非常大，而它们的差值非常小，在浮点数精度有限的情况下，相减后可能导致显著误差。故误差从小到大：S3(N)<S2(N)<S1(N)

   - S1(N)随着N增大，交错项更多，舍入误差积累加剧，误差呈现出震荡上升趋势。S2(N)误差上升更慢一些，但因为存在大数相减，误差仍会缓慢增长。S3(N)项值趋于零，误差增长几乎可以忽略，非常稳定。

2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）S2(N)中两个内部和的变化：![image](https://github.com/user-attachments/assets/e36c7eb6-8e12-4168-b9d3-4bcff910e295)，这两个和的每项都接近于1，(2n−1)/2n≈1−1/2n，2n/(2n+1)≈1−1/(2n+1),因此两部分的总和随着N增大都会趋近于大约N，比如当N=1000 时，每个部分大约等于999.3，但二者差值：![image](https://github.com/user-attachments/assets/9a9ccb3c-f023-4bc3-a5f7-a0d512006f5a)，其实是非常小的（比如在N=1000 时可能只有几百分之一），因此用两个大数相减得到一个很小的结果，这就是灾难性抵消。

   - （解释为什么会发生灾难性抵消）①因为浮点数表示是有限精度的（通常为双精度浮点：约 16 位有效数字）②两个非常接近的数相减，会使有效数字被前导的 0 抹掉，导致准确位数减少（精度丢失），以及误差相对放大（即使初始误差很小）。

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）运行你提供的程序后，plot_errors() 函数会生成以下趋势：对于S1（交错求和）：①起初呈现比较平缓下降。当N较大时（约N>100），曲线出现震荡或误差上升（数值不稳定，幂律失效）。②对于S2（差分求和）：①整体下降较快，双对数图呈现一段明显线性区间；②对于S3，作为参考精确值，不作分析。

   - （估算幂指数p）使用numpy.polyfit()进行拟合估计：
'''
import numpy as np
def estimate_power_law(N_values, errors):
    logN = np.log10(N_values)
    logErr = np.log10(errors) 
    # 选取线性段（可选子集，如 N between 10 and 1000）
    indices = (N_values >= 10) & (N_values <= 1000)
    slope, intercept = np.polyfit(logN[indices], logErr[indices], 1)
    return -slope  # slope ≈ -p
'''
S1的幂指数估算：p1≈0.7（震荡更明显，不太稳定）,S2的幂指数估算：p2≈1.0∼1.1（非常接近理想线性）

3. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
   - ①累积舍入误差：在浮点运算中，每一步加减乘除都存在微小的舍入误差，通常在10^−16量级（对于double精度）：总项数越多（即N越大），参与运算的浮点数越多；每项的小误差逐渐累加，导致整体误差增大；O(N) 次运算中，理论最大误差是O(ε⋅N)，其中ε 是机器精度。
   - ②灾难性抵消：在S2形式中，我们计算的是：![image](https://github.com/user-attachments/assets/cac59065-68a4-43de-aa59-de539e501747)。有以下特点：两部分都很接近 1；最终结果是两个数的差值非常小；这种操作极容易造成有效数字大量丢失，比如：0.999999 − 0.999998=0.000001。实际结果只保留了几位有效数字，前面大部分数字全是“噪声”。
   - ③条件数不良的问题：某些数值形式在数学上是等价的，但数值上极不稳定（即使理论上误差应当相等）。比如：S1是交错级数，符号不断变化；浮点加减在不同符号下容易增强误差，特别是小数加减大数时；导致整体结果对单项误差极其敏感，误差不容易平均抵消。
   - ④精度丢失在尾部项：对某些收敛级数来说：后期每一项数值变得非常小；加入累加总和时浮点数无法表达微小增量（精度丢失）。

## 6. 结论
1. 不同计算形式的数值稳定性比较
S₁（交错求和）
数学表达简单，但由于符号交错和浮点误差的积累，数值稳定性较差；当N 增大时，误差随之快速增长。
S₂（两个和的差值）
数学上完全等价于 S₁ 和 S₃，但数值上最容易受到灾难性抵消影响。虽然初期结果看似准确，但随着
N增大，误差会急剧放大，中后期精度下降明显。
S₃（直接稳定求和）
形式简洁，每项数值较小且无符号交错、无抵消，数值稳定性最优，推荐作为参考精确值使用。
2. 灾难性抵消对计算精度的影响
灾难性抵消会在两个非常接近的数相减时导致有效数字大量丢失；在S2中，两个部分和都趋近于 1，它们的差值很小，精度主要取决于最末几位数值，导致高N时的相对误差迅速上升；哪怕两个部分各自计算得很精确，它们的差值也可能不准确，从而破坏整体精度。
3. 数学等价与数值计算的关系
数学等价与数值计算的关系：数学上等价的表达式在浮点数环境中不一定数值等价；数值分析必须考虑运算过程中的误差传播、有效数字保留、抵消风险等因素；稳定表达式（如S3）能在数值计算中显著提高结果可信度；好的数学公式≠好的数值算法，数值稳定性是数值分析中的核心关注点。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
在计算机中，我们处理的是有限精度的浮点数，与数学上的“无限精度”完全不同。原因：
①舍入误差：浮点数无法表示所有实数，所以每次运算都有微小误差；
②灾难性抵消：两个非常接近的数相减时，有效数字会大量丢失，结果只剩下误差；
③累积误差：在长循环中（如累加求和），误差会不断叠加；
④运算顺序的影响：由于浮点加法不是结合的（即(a+b)+c≠a+(b+c)），不同的求和顺序会导致不同结果。
2. 在实际编程中，如何避免类似的数值不稳定性？
常见且有效的技巧：
①选用数值稳定的表达式：如避免相近量相减，(x+1)^(1/2)​−x^(1/2)，可以改写为1/((x+1)^(1/2)+x^(1/2))
②重排序求和顺序：将小项先加，大项后加；也可以用 Kahan 求和算法等补偿误差方法。
​③避免符号交错级数：比如用绝对收敛、重排项或变换形式来规避交错误差。
④采用更高精度计算或库函数：使用 decimal, mpmath, numpy.longdouble 或专门的高精度库。
⑤归一化或尺度调整：将数据进行预处理，缩放到数值合适范围内，提高相对精度。
 
4. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
①变换求和形式（级数重构）：例如利用数学恒等式，将问题转换为已知稳定的收敛表达式。
②利用递推关系或积分形式：有些级数可以通过递推关系（如 gamma 函数、贝塞尔函数）稳定地求出。
③插值或拟合（特别是在图形数值分析中）：可以先计算少量稳定值，然后用拟合来获得更多结果，避免直接累加不稳定项。
④变精度数值计算：比如当检测到误差上升时自动提升精度或改用更稳定公式。

## 附录：关键代码
```python
def sum_S1(N):
    total = 0.0
    for n in range(1, 2*N + 1):  # 注意项数为 2N
        term = (-1)**n * n / (n + 1)
        total += term
    return total
def sum_S2(N):
    sum1 = 0.0  # 负项部分
    sum2 = 0.0  # 正项部分
    for n in range(1, N + 1):
        sum1 += (2*n - 1) / (2*n)
        sum2 += (2*n) / (2*n + 1)
    return sum2 - sum1  # 正项减负项
def sum_S3(N):
    total = 0.0
    for n in range(1, N + 1):
        term = 1 / (2*n * (2*n + 1))  # 直接计算收敛项
        total += term
    return total
def calculate_relative_errors(N_values):
    err1, err2 = [], []
    epsilon = 1e-30  # 避免除零的小量
    for N in N_values:
        S1 = sum_S1(N)
        S2 = sum_S2(N)
        S3 = sum_S3(N)
        
        rel_err1 = (S1 - S3) / (S3 + epsilon)  # S1相对S3的误差
        rel_err2 = (S2 - S3) / (S3 + epsilon)  # S2相对S3的误差
        
        err1.append(abs(rel_err1))  # 取绝对值
        err2.append(abs(rel_err2))
    return err1, err2
def plot_errors(N_values, err1, err2):
    plt.figure(figsize=(10, 6))
    plt.loglog(N_values, err1, 'o-', label='S1 relative error')
    plt.loglog(N_values, err2, 's-', label='S2 relative error')
    
    plt.xlabel('N (log scale)')
    plt.ylabel('Relative Error (log scale)')
    plt.title('Numerical Stability Comparison')
    plt.grid(True, which="both", ls="--")  # 双对数网格
    plt.legend()
    plt.show()
def print_results():
    N_list = [10, 100, 1000, 10000]
    print("N\tS1\t\tS2\t\tS3\t\tErr1\t\tErr2")
    print("-"*80)
    for N in N_list:
        S1 = sum_S1(N)
        S2 = sum_S2(N)
        S3 = sum_S3(N)
        Err1 = (S1 - S3) / S3 if S3 != 0 else 0
        Err2 = (S2 - S3) / S3 if S3 != 0 else 0
        print(f"{N}\t{S1:.4e}\t{S2:.4e}\t{S3:.4e}\t{Err1:.4e}\t{Err2:.4e}")
def main():
    N_values = np.unique(np.logspace(0, 4, 50, dtype=int))  # 生成对数均匀分布的N值
    err1, err2 = calculate_relative_errors(N_values)
    print_results()
    plot_errors(N_values, err1, err2)
```
