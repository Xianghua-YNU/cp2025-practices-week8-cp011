# 实验三：数值积分实验报告

## 1. 实验目的
- 理解数值积分的基本原理
- 实现并比较矩形法和梯形法两种数值积分方法
- 分析不同积分方法的收敛性和精度
- 探究步长对数值积分精度的影响

## 2. 实验原理
### 2.1 问题描述
计算定积分：
$$
I = \int_{0}^1 \sqrt{1-x^2} d x
$$
该积分表示1/4圆的面积，其解析解为 $\frac{1}{4}\pi \approx 0.7853981633974483$。

### 2.2 数值方法
#### 2.2.1 矩形法（左矩形法）
将积分区间 $[a,b]$ 等分为 $N$ 个子区间，每个子区间长度为 $h=(b-a)/N$，用左端点函数值近似该子区间上的平均函数值：
$$
\int_a^b f(x)dx \approx h\sum_{k=0}^{N-1} f(x_k), \quad x_k = a + kh
$$

#### 2.2.2 梯形法
同样将积分区间等分为 $N$ 个子区间，但使用梯形面积近似每个子区间上的积分：
$$
\int_a^b f(x)dx \approx \frac{h}{2}[f(a) + 2\sum_{k=1}^{N-1}f(x_k) + f(b)]
$$

## 3. 实验结果
### 3.1 数值结果
（填写不同N值下的计算结果表格）

| N | 矩形法结果 | 矩形法相对误差 | 梯形法结果 | 梯形法相对误差 |
|---|------------|----------------|------------|----------------|
| 10 |           |                |            |                |
| 100 |          |                |            |                |
| 1000 |         |                |            |                |
| 10000 |        |                |            |                |

### 3.2 误差分析图
（插入误差-步长关系的对数图，并说明观察到的现象）![Figure 2025-04-23 104033](https://github.com/user-attachments/assets/2b954249-5759-4d62-95e4-16ebabbb7ff3)


## 4. 分析与讨论
### 4.1 收敛性分析
- 矩形法的收敛阶数：（填写并解释）
- 梯形法的收敛阶数：（填写并解释）
- 两种方法收敛性的比较：（分析优劣）

### 4.2 精度分析
- 在相同N值下两种方法精度的比较
- 影响精度的主要因素分析
- 如何选择合适的N值以达到期望精度

### 4.3 计算效率
- 计算时间随N的变化规律
- 精度和计算时间的权衡

## 5. 结论
（总结本实验的主要发现，特别是关于两种方法的优缺点和适用场景）

## 6. 思考题
1. 为什么梯形法通常比矩形法更精确？：
原理差异：矩形法是用一系列矩形面积近似曲边梯形面积，以区间端点或中点函数值作为矩形高度。而梯形法是用梯形面积近似曲边梯形面积，将积分区间  分割后，把相邻节点函数值连线形成梯形 。
误差分析：从误差角度，矩形法局部误差是一阶无穷小
2. 如果被积函数在积分区间内有奇点（如 $\int_0^1 \frac{1}{\sqrt{x}}dx$），这些方法是否仍然适用？为什么？
奇点影响：当被积函数在积分区间内有奇点时，传统梯形法和矩形法通常不适用。
误差问题：矩形法和梯形法基于函数在区间上相对平滑连续的假设构建。存在奇点时，函数在奇点附近变化剧烈，用矩形或梯形近似会产生极大误差，无法有效收敛到真实积分值。 不过，若对含奇点的积分进行适当变换或处理（如拆分区间、奇异积分的特殊数值方法），在一定条件下可改善适用性，但常规矩形法和梯形法直接使用效果不佳。
3. 如何改进这些方法以获得更高的精度？
无论是矩形法还是梯形法，增加积分区间的划分数量，即减小子区间长度  ，能降低误差。根据误差公式，随着  减小，误差会相应减小。

## 附录：代码实现
```python
# 在此粘贴关键代码片段
```
def rectangle_method(f, a, b, N):
    """矩形法（左矩形法）计算积分"""
    h = (b - a) / N
    result = 0.0
    
    for k in range(1, N + 1):
        x_k = a + h * (k - 1)  # 左端点
        y_k = f(x_k)
        result += h * y_k
    
    return result

def trapezoid_method(f, a, b, N):
    """梯形法计算积分"""
    h = (b - a) / N
    result = 0.0
    
    for k in range(1, N + 1):
        x_k_minus_1 = a + h * (k - 1)  # 左端点
        x_k = a + h * k  # 右端点
        result += 0.5 * h * (f(x_k_minus_1) + f(x_k))
    
    return result

def calculate_errors(a, b, exact_value):
    """计算不同N值下各方法的误差"""
    N_values = [10, 100, 1000, 10000]
    h_values = [(b - a) / N for N in N_values]
    
    rect_errors = []
    trap_errors = []
    
    for N in N_values:
        # 矩形法
        rect_result = rectangle_method(f, a, b, N)
        rect_error = abs((rect_result - exact_value) / exact_value)
        rect_errors.append(rect_error)
        
        # 梯形法
        trap_result = trapezoid_method(f, a, b, N)
        trap_error = abs((trap_result - exact_value) / exact_value)
        trap_errors.append(trap_error)
    
    return N_values, h_values, rect_errors, trap_errors
