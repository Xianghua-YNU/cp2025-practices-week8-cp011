# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|10	|2.92896825	|2.92896825	|0.00000000e+00
|100	|5.18737752	|5.18737752	|1.71219160e-16
|1000	|7.48547086	|7.48547086	|3.55960942e-16
|10000|9.78760604	|9.78760604	|3.81129905e-15


### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![计算物理实验第七周作业——七周](https://github.com/user-attachments/assets/37f2a9d5-23a7-4ab0-88d5-18a644eac26a)


## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - 相对差异随n增加而增加，但增加速率减缓

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）
   - 如果按照从小到大的顺序，也就是后加1/n，再加1/(n-1)，直到加到1，当n很大时，前面的项会非常小，比如1/1000000这样的小数。当这些小数被加到当前的和里时，如果当前的和已经很大，那么小的数可能会因为浮点数的精度问题而被舍入掉，无法对总和产生应有的贡献。

### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）

## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
. 如果按照从小到大的顺序，也就是后加1/n，再加1/(n-1)，直到加到1，这时候可能的问题是什么呢？比如当n很大时，前面的项会非常小，比如1/1000000这样的小数。当这些小数被加到当前的和里时，如果当前的和已经很大，那么小的数可能会因为浮点数的精度问题而被舍入掉，无法对总和产生应有的贡献。

3. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
   从大到小求和



5. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
Kahan求和算法，Kahan算法通过补偿的方法来减少误差，是个有效的方法。另外，可能还有分治法，把数组分成小块，分别求和再合并，这样可以减少累积误差。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```def sum_up(N):
    """从小到大计算调和级数和"""
    result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / n
    return result

def sum_down(N):
    """从大到小计算调和级数和"""
    result = 0.0
    for n in range(N, 0, -1):
        result += 1.0 / n
    return result

def calculate_relative_difference(N):
    """计算两种方法的相对差异"""
    s_up = sum_up(N)
    s_down = sum_down(N)
    return abs(s_up - s_down) / abs((s_up + s_down) / 2.0)
